 # 1. Description of the F1 application
 
The visualizations are aimed at giving insight how rule changes, also called formulas, have an effect on team dominance. Consensus exists among F1 fans that team dominance rarely survives a significant rule change. This application empowers the user to find out wether this is true or not.
 
 # 2. Technical design
 
## &nbsp;&nbsp; 2.1 High level overview

#### 1. Python
Python handles the data structure which is used by JavaScript to generate visualizations.

#### 2. JavaScript
JavaScript handles the actual initiations and updates of the visualizations. F1.js follows a linear flow, from map initiation to pie chart drawing and updating. After the data has been loaded in a queue, a main function is called. This main function handles all logic for drawing the map. The rest of the visualizations are cascades from the map init function, and initialised and updated with on clicks of relevant elements of another visualization. The general flow of F1.js is as follows:

1. Load DOM
2. Load Data
3. Map init
    * marker on click function defined
      * init line graph
4. Line graph init
    * Line graph update function defined
    * overlay on click function defined
      * init pie chart
5. Pie chart init
    * pie chart update function defined
      * overlay on click updated to update pie chart

Functions relevant to each part, e.g. map color gradients and functions that get indices from the overlay of the line graph are explained in detail in **section 2.2.3**.

## &nbsp;&nbsp; 2.2 Low level overview

### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2.1 Data
 
There are several datasets generated by request.py. This file uses GET request to an API, Ergast, to fetch, format and store data in .json files. After fetching and processing the data, the following data sets are generated with the following purposes:

1. choro.json
    * Initiate and update the dataMaps colors and values per country
2. markers.json
    * Drawing markers on the dataMap
    * Information to show in dataMap popup
3. laptimes.json
    * Drawing the line graph with laptimes per season
4. winners.json
    * Drawing and updating the pie chart with constructor wins per season
5. rules.json
    * Updating the rule tables next to the line graph

### 2.2.2 Files

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data_gen folder

---
#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; request.py
Logic for performing a GET request to the Ergast API and for selecting and formatting data from the request.

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; helpers.py
Helper functions for selecting and formatting data into seperate datasets.

---
#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main folder
---
#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F1.js
Logic for the visualizations. Handles vizualization of seperate data sets, most importantly:
1. Map with markers
    * Uses markers.json to draw markers on a world map
    * Uses choro.json to fill in countries according to country specific data values
2. Line chart with laptimes
    * Uses laptimes.json
3. Pie chart with constructor wins per season
    * Uses winners.json
4. A table with the most recent rule set
    * Uses rules.json

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; project.html
HTML markup file. Loads in all relevant libraries, stylesheets, scripts and creates a general layout of the site.

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scrolling-nav.js
Standard bootstrap scrolling nav scipt, handles screen scrolling to sections of the site. If the user selects a nav option from the nav-bar on the top of the page, the screen is smoothly scrolled to the relevant section.

---
#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; css folder
---

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bootstrap.min.css
Style document for general layout of the differenct site sections and the site nav-bar.

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; project.css
Style document for general layout of the visualizations, titles and any non data relevant colors on the site, e.g. background colors of countries of which no data exists.

#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scrolling-nav.css
Style document containing padding. Used in combination with scrolling-nav.js to correctly fit sections after auto scrolling from nav-bar.

---
#### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libs folder
---
Groups all dependencies for F1.js. Includes the following libraries:

**1. d3**
  * Data Driven Documents. Popular library used for creating data dependend visualizations and animations in JavaScript.
  * Link: https://github.com/d3/d3

**2. d3-queue**
  * Used for loading datasets asynchonously.
  * Link: https://github.com/d3/d3-queue

**3. d3-tip**
  * Used for creating tooltips for specific user actions.
  * https://github.com/Caged/d3-tip

**4. d3-interpolate-path**
  * Offers a better interpolation method than the standard interpiolation method delivered with d3. Used for updating the line graph.
  * Link: https://github.com/pbeshai/d3-interpolate-path

**5 dataMaps**
  * Built on top of d3 to generate easy to use data maps. Used to generate the F1 circuit map.
  * Link: http://datamaps.github.io/
  
**6. topojson**
  * Built on top of GeoJSON and encodes topology used by dataMaps. Used to generate a world map and country borders.
  * Link: https://github.com/topojson/topojson/wiki
  
**7. bootstrap**
  * Popular library for front-end layouts and styiling of the site.
  * Link: https://github.com/twbs/bootstrap

**8. jquery**
  * Popular library for DOM traversal, interaction and event handling. Bootstrap dependency.
  * Link: https://github.com/jquery/jquery

**9. jquery easing**
  * Built on top of jquery, used for easy animations of DOM elements. Used by scrolling-nav.js to ease scroll animation
  * Link: https://github.com/gdsmith/jquery.easing

 ### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2.3 Functions (F1.js)

```javascript
function drawmap() {};
```
This function initiates the map and all map functionality. It calls the following notable functions:
1. gradientBuilder()
2. mapDataBuilder()
3. drawMarkers()
4. buildLineChart()
5. zoom()
6. center()
7. showHideMarkers()
8. slideUpdateMap()
9. buildLegend()

```javascript
function gradientBuilder() {};
```
Called from **drawMap();**, this functions builds a semi linear color scale. The colors are coupled to an int, the smallest value is given a non linear color. Any color after that is scaled according to a linear scale. This scale is used in **mapDataBuilder();** to build an object wich is recognised by datamaps and can be used in the dataMaps method **updateChoropleth();** to update the map colors. These colors now correspond to int values on the map. This method is coupled to a user controlled slider.

One drawback is that it takes more work to implement this kind of scale than a simple d3 linear scale. However, one advantage is that there is no need for an extra check in the **mapDataBuilder();** function to check for the smallest non linear value, and the color coupled to it. This check would need to be done on every update of the slider, while **gradientBuilder();** is only initialised once and passes the function to a different variable that can be called at will.

The color scale also bundels all value: color 'keys' in one function. This is more logical than a linear scale plus an extra check somewhere else in the code.

Moreover, this color scale can easily be altered for any kind of int data, making the map more flexible for later updates and datasets. The predefined argument is already included for easy updates of scales.

```javascript
function mapDataBuilder() {};
```
Called from **drawMap();** to init map colors of countries with an F1 GP in 1950. It is subsequently called from **slideUpdateMap();** to update the map colors after user input from the season slider. It builds a dictionary used by the **updatechoropleth();** method to color countries according to data values, a number of races in this case.

```javascript
function slideUpdateMap() {};
```
Called from an anonymous function within the done* parameter of the dataMap in the **drawMap();** function to ensure the map elements are ready for slide updates.

It uses a slider input element to select a season. Calling **mapDataBuilder();** it builds a dictionary with color values and race values for the selected season. Used by the **updatechoropleth();** method to update the dataMaps country colors.

```javascript
function drawMarkers() {};
```
Called from an anonymous function within the done* parameter of the dataMap in the **drawMap();** function to ensure the map bubbles method is ready. This function draws the markers on the map using the bubbles method and adds a popup displaying the circuit name.

A strange 'feature' of dataMaps is that the radius parameter must be passed to the map.bubbles() dataMaps method, but the radius of the markers must also be initialised with a d3 selection. This is some extra work, but the d3 marker selection is needed later anyways for zooming and translating the bubbles across the map.

The function returns the marker selection and also the radius for later use to reduce redundent d3 selections. The selection is used by **zoom();** and **center();** to correctly reposition the markers after the user pans, zooms or centers the map on a country.

```javascript
function zoom() {};
```
Called from an anonymous function within the done* parameter of the dataMap in the **drawMap();** function to ensure the projection method is ready.

It ensures proper mouse click panning and scroll zooming on the map using the map projection.

```javascript
function center() {};
```
Called from the same place as **zoom();** for the same reason, it ensures proper mouse country click panning on the map. 

```javascript
function showHideMarkers() {};
```
Called from an anonymous function within the done* parameter of the dataMap in the **drawMap();** function to ensure the markers have been drawn.

Groups logic for showing and hiding markers. The display styles are used to make markers non clickable, as making the r attribute equal to 0 still enabled an on click and the mouseover tooltip. Transitions and delays are grouped for ease of use and updating the function. The delay ensures a proper hide animation.

```javascript
function buildLegend() {};
```
Called from the **drawMap();** function.

Builds a configurable legend bar for the dataMap. Adds mouse hover selection functionality, a d3-tip and calls the **borderChange();** function which changes the border thickness of selected countries. All the functionality is based on the amount of F1 races in a country. A user can select an amount via the legend by hovering over it with the mouse. The amount of races selected via the legend is calculated by the **getLegendValue();** function. This value is used by the tip to give the user feedback on the selected amount, and the **borderChange()** function to actually change the borderthickness of the countries with a race amount corresponding to the selected amount.

```javascript
function borderChange() {};
```
Called from the **buildLegend();** function.

Using an integer value and all country isos which will host at least one GP, it selects all countries where the race amount is equal to the integer value. Then it increases the border thickness, otherwhise border thickness is reset.

```javascript
function buildLineChart() {};
```
Called from an anonymous function within the done* parameter of the dataMap in the **drawMap();** function to ensure the markers have been drawn.

It groups logic necessary for building and updating the line graph. First it draws empty axes by processing empty time and date domains with empty tick formats. It also adds an empty line and focus elements. 

These include:
1. The two focus lines
    * An x-line
    * A y-line
2. The focus circle
3. The focus overlay

These are grouped in a <g> element which is hidden with a, display: none, style. The result are two empty axes, signalling to the user that these can be filled with data after an input. The empty elements are created to be easily updated with the **updateLineGraph();** function.
 
The markers are used to update the (first empty) line graph with laptime data from a circuit after a marker click event. The stored a circuitId, which keys laptimes in laptimes.json. Using the id, the correct laptimes are fetched and formatted using the **forceValue();** function. The formatted laptime data for the selected circuit is then used in the **updateLineGraph();** function. The title of the line graph is updated using the marker circuit_name, which is nicer to read than the id. This name is passed to the **updateTitle();** function.

```javascript
function forceValue() {};
```
Called from the marker on click event in the **buildLineChart();**.

It forces simple year strings, like "2017", into a JavaScript date objects e.g. *Thu Jan 01 1970 00:00:00 GMT+0100*. This object format is better suited for d3 axes, as the years can be displayed easily without displaying delimiter signs, e.g. 2,017. The same is true for the laptime info. The date object does have to be formatted back to a user readable format. The **timeParse();** function transforms the date object back into a simple string.

For laptime info, which is stored in milliseconds in laptimes.json, The year is not important. So it is formatted directly as a new date object. This results in a 1970 date object, e.g. *Thu Jan 01 1970 **%M:%S:%L** GMT+0100*. The minutes, seconds and milliseconds can be fetched using the **d3.time.format("%M:%S:%L");** method, which converts the date object into a string, e.g. **"01:23:456"**. This also circumvents the need to do simple math for time conversion.

```javascript
function updateLineGraph() {};
```
Called from the marker on click event in the **buildLineChart();**.

Handles the line chart updates to reflect changes in circuit selection by the user via the map. Instead of empty domains, circuit specific information, which is passed via the marker on click event in the **buildLineChart();** function, is used to update the domains. The domains are then used to re-scale the axes.

The line is updated via *tween interpolation*, using the previous line to smoothly transition to the next line. Stock d3 interpolation does not handle changes in data length and missing data smoothly, so the *d3-interpolate-path library* is used to handle interpolation.

The overlay is given new display styles every update, these hide and show focus elements on mouse in and out events. This is some extra work, but has some features that simplify the script. Mainly, this layout does not require a check if the overlay has been updaten before. On mouse move, the mouse x-coordinate is passed to the **getTrueData();** function, which returns the laptime data indexed at the season the user has selected with the mouse's x-position. Using this data, the x and y coordinates of each season and laptime of that season can be calculated. These are then used to draw the y- and x-focus lines. These focus-lines cross the line of the line graph exactly at the value of each laptime for each season.

This allows an on click and update to be added to the graph overlay element, instead of the line graph circles. The user can now more easily select a season, as he/she does not have to click on a small circle for a selection, but can click anywhere on the line graph.

The overlay on click event is now ready to:
1. Build the pie chart
  * **buildPieChart();**
2. Change the rule tables next to the line graph
  * **changeRules();**
3. Update the title of the pie chart
  * **updateTitle();**

```javascript
function getTrueData() {};
```
Called from:
1. graph overlay on mousemove in **updateLineGraph();**
  * Provides positioning data for the focus lines
2. graph overlay on click in **buildPieChart();**
  * Used to fetch the season the user selects with his/her mouse position

When the user wants to select a season specific laptimes information from the line chart, this is the function that handles it. First it uses the invert method of the xScale function. This means translating a mouse coordinate to a date string, essentially the reverse process of getting drawing x-axis ticks. Then it bisects this date string into the dataset, returning the index where the date should be stored if inserted into a date sorted data set. Using the index, the trailing and leading datasets are used to find the one closest to the mouse location.

```javascript
function buildPieChart() {};
```
Called from the overlay on click event in **updateLineGraph();**.

It groups logic necessary for building and updating the pie chart. The pie chart is initiated by giving all slices a start and end-angle of 0 radians. This produces an empty pie chart. Then, using the **arctween();** function, it interpolates the value of the end-angles and start-angles on a slice per slice basis. The previous slice's end-angle, is the next slice's start angle. This is handled by the pie(data) function, which returns the start and end angles for each slice. An animation ensures a smooth transition between the empty pie chart, and the fully filled one.

The overlay on click event, first initiated in the **updateLineGraph();** function, is also updated. It is now ready to:
1. Update the pie chart
  * **updatePie();**
2. Change the rule tables next to the line graph
  * **changeRules();**
3. Update the title of the pie chart
  * **updateTitle();**

```javascript
function updatePie() {};
```



```javascript
function updateTitle() {};
```
Called from the line graph overlay and markers on click events.

Updates title html elements after the user selects a circuit from the map, or a season from the line graph. The class is passed as a string, as is the text the title is to be updated with. The class is used to select the correct element(s) and the text is used to update the element's html.

# Challenges & changes

## Python data gen
The focus was not on efficiency, as the data only needs updating once a year.

## Table update and data structure
A challenge was finding a logical way to update a table to the most recent ruleset. The most difficult part was finding a simple way to do 1 of two things:
1. Find a simple way to fill a data object with mostly the same data for all seasons
2. Find a way to revert back to the most recent change of a rule subset (like the engine size or fuel limit)

As the information is not readily available and has to be filled in by hand in excel, the choice was to go for the second option. This saves time updating the information and decreases the amount of duplicate info in the rules dataset. The trade-off is that more work has to be done at the back end to find the most recent ruleset. 

This is implemented by mostly filling the dataset with empty strings, and bisecting a list of all seasons where the rules have changed. If the user selected a season where the rules have not changed, the bisected index is used to find the most recent season where the rules have changed. The rules are keys and the text are the values, key by key a check is made is the text value is not empty. If it is, the index is decreased to an even earlier season where the rules have changed unil the most recent rulechange for the key is found.

## Pie chart update
Another challenge was the pie chart update. It turns out the slices are not, locked, to each label. If an update is made, the order of the labels in the dataset and the order of the slices determine which slice gets which data value. This means if the first slice represents Ferrari, and Mercedes is in the 0th index of the new dataset, the Ferrari slice updates with the mercedes win amount. The ideal update would of be to exit the Ferrari slice and enter the mercedes slice. 

However, due to time constraints and other important focus points, a simple fix was chosen. The dataset now includes all possible winners in alphabetical order (total of 44) at all times. Win values are 0 if slices need to be 'exited'. This creates consistency in the pie chart update, but is not ideal as there should be no need to keep empty datasets around.
